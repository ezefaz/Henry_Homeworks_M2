{"version":3,"sources":["actions/index.js","components/Counter.js","reducers/index.js","index.js"],"names":["INCREMENT","DECREMENT","Counter","incrementIfOdd","props","count","increment","incrementAsync","setTimeout","this","onClick","decrement","Component","connect","state","type","initialState","store","createStore","action","ReactDOM","render","document","getElementById"],"mappings":"0LAAaA,EAAY,YACZC,EAAY,Y,OCGnBC,E,4MAEFC,eAAiB,WAEb,EAAKC,MAAMC,MAAQ,IAAM,GAAK,EAAKD,MAAME,a,EAI7CC,eAAiB,WAEbC,WAAW,EAAKJ,MAAME,UAAW,M,4CAGrC,WAAU,IAAD,OAGL,OACI,4CACgBG,KAAKL,MAAMC,MAD3B,SAEI,wBAAQK,QAAS,WAAO,EAAKN,MAAME,WAAnC,gBAGA,wBAAQI,QAAS,WAAO,EAAKN,MAAMO,WAAnC,wB,GAtBMC,aAoDPC,eAVS,SAACC,GACrB,MAAO,CACHT,MAAOS,EAAMT,SAQmB,CAAEC,UDhDjB,WAEzB,MAAO,CAACS,KAAMf,IC8CuCW,UD5C5B,WAEvB,MAAO,CAACI,KAAMd,KC0CDY,CAAmDX,G,OCtD5Dc,EAAe,CACnBX,MAAO,GCSHY,EAAQC,aDHC,WAAmC,IAAlCJ,EAAiC,uDAAzBE,EAAcG,EAAW,uCAC/C,OAAQA,EAAOJ,MACb,KAAKf,EACH,OAAO,2BAAIc,GAAX,IAAkBT,MAAOS,EAAMT,MAAQ,IAGzC,KAAKJ,EAED,OAAO,2BAAIa,GAAX,IAAkBT,MAAOS,EAAMT,MAAQ,IAC3C,QACE,OAAO,eAAIS,OCDjBM,IAASC,OACP,cAAC,IAAD,CAAUJ,MAAOA,EAAjB,SACE,cAAC,EAAD,MAEFK,SAASC,eAAe,W","file":"static/js/main.0edfe919.chunk.js","sourcesContent":["export const INCREMENT = 'INCREMENT';\nexport const DECREMENT = 'DECREMENT';\n\n// Nuestras actions (action creators) devolverán un paquete de actions que nuestro reducer recibirá. \n// ¿Cómo es el paquete de acción? Tengan en cuenta que el creador de la acción no es en absoluto responsable \n// de manejar ninguna de las lógicas actuales de actualización del store central de Redux.\n// Eso se lo deja al reducer(s).\n\nexport const increment = () => {\n  // Completa la funcion\nreturn {type: INCREMENT}};\n\nexport const decrement = () => {\n  // Completa la funcion\n  return {type: DECREMENT}};","import React, { Component } from \"react\";\nimport { connect } from 'react-redux'; // el conect conecta el store y las acciones con nuestros componentes.\nimport { increment, decrement } from '../actions';\n\nclass Counter extends Component {\n    // Extra Credit\n    incrementIfOdd = () => {\n      //Implementar una función de incremento que sólo aumenta si el valor del contador es impar\n        this.props.count % 2 !== 0 && this.props.increment(); // esto lo que hace es store.dispatch({type: increment})\n\n    };\n    // Extra Credit\n    incrementAsync = () => {\n        //  Implementar una función de incremento que aumenta después de esperar un segundo\n        setTimeout(this.props.increment, 1000);\n    };\n\n    render() {\n        // Completa las funciones onClick de los botones\n        // Al hacer clic en estos botones, el recuento debe disminuir o aumentar en consecuencia\n        return (\n            <p>\n                Clickeado: {this.props.count} veces\n                <button onClick={() => {this.props.increment}}>\n                    + {/* Incremeta */}\n                </button>\n                <button onClick={() => {this.props.decrement}}>\n                    -  {/* Decrementa */}\n                </button>\n                 {/* Si quieres hacer los extra credit puede descomentar las lineas de abajo */}\n                {/* <button onClick={this.incrementIfOdd}>\n                    incrementa si es impar\n                </button>\n                <button onClick={this.incrementAsync}>\n                    Incrementa despues de un segundos\n                </button>  */}\n            </p>\n        );\n    }\n}\n\n// La función mapStateToProps especifica qué porción del árbol de estados necesita recibir este componente.\n// En este caso, dado que nuestro store de redux sólo almacena el valor del contador,\n// este componente recibe el estado completo.\n// Sin embargo, en una aplicación redux más compleja,\n// recibiría sólo las partes relevantes que necesita del objeto de estado.\nconst mapStateToProps = (state) => {\n    return {\n        count: state.count\n    };\n};\n\n// Se llama a la función de connect para que este componente conozca el resto de la arquitectura de redux.\n// Sin esto, este componente es sólo un componente tonto de React.\n//Pasamos todas las funciones que dependen de Redux, junto con el propio componente,\n// para que Redux se dé a conocer a este componente.\nexport default connect(mapStateToProps, { increment, decrement })(Counter);\n","import { INCREMENT, DECREMENT } from '../actions';\n\nconst initialState = {\n  count: 0\n}\n\n// Nuestro reducer que maneja nuestros dos casos de acción incremento y decremento.\n// Recibe el estado de nuestro store, junto con una action creada por nuestro action creator. \n// ¿Qué tiene que hacer el reducer con el contador de cada caso?\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case INCREMENT:\n      return {...state, count: state.count + 1\n        } \n        \n    case DECREMENT:\n    // Fill para este otro\n        return {...state, count: state.count - 1}\n    default:\n      return {...state};\n  }\n};","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { legacy_createStore as createStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport Counter from './components/Counter';\nimport counter from './reducers';\n\n// Esta línea instancia nuestro store central de Redux.\n// La función `createStore` recibe el reducer\n// que es responsable de la actualización del store , junto\n//con cualquier estado inicial con el que queramos que\n//empiece el store (que en este caso es ninguno).\nconst store = createStore(counter);\n\n// Aquí, envolvemos nuestro componente principal React dentro de las etiquetas del Provider,\n// que vienen del paquete react-redux.\n// Esto es necesario porque el store necesita saber hacia dónde está pasando su estado. \n// El componente Provider es donde \"vive\" el store.\nReactDOM.render(\n  <Provider store={store}>\n    <Counter />\n  </Provider>,\n  document.getElementById('root')\n);"],"sourceRoot":""}